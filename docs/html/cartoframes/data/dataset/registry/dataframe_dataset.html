<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>cartoframes.data.dataset.registry.dataframe_dataset API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cartoframes.data.dataset.registry.dataframe_dataset</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import pandas as pd
from warnings import warn
from tqdm import tqdm

from carto.exceptions import CartoException, CartoRateLimitException

from .base_dataset import BaseDataset
from ....utils.columns import Column, normalize_names
from ....utils.geom_utils import decode_geometry, compute_geodataframe, \
    detect_encoding_type, save_index_as_column
from ....utils.utils import map_geom_type, load_geojson, is_geojson


# avoid _lock issue: https://github.com/tqdm/tqdm/issues/457
tqdm(disable=True, total=0)  # initialise internal lock


class DataFrameDataset(BaseDataset):
    def __init__(self, data, credentials=None, schema=None):
        super(DataFrameDataset, self).__init__()

        self._df = data

    @staticmethod
    def can_work_with(data):
        return isinstance(data, pd.DataFrame) or is_geojson(data)

    @classmethod
    def create(cls, data, credentials=None, schema=None):
        if is_geojson(data):
            data = load_geojson(data)

        save_index_as_column(data)

        return cls(data)

    @property
    def dataframe(self):
        &#34;&#34;&#34;Dataset DataFrame&#34;&#34;&#34;
        return self._df

    def get_geodataframe(self):
        &#34;&#34;&#34;Converts DataFrame into GeoDataFrame if possible&#34;&#34;&#34;
        gdf = compute_geodataframe(self)
        if not gdf.empty:
            self._df = gdf

        return self._df

    def download(self, limit, decode_geom, retry_times):
        self._is_ready_for_dowload_validation()

    def upload(self, if_exists, with_lnglat):
        self._is_ready_for_upload_validation()

        normalized_column_names = _normalize_column_names(self._df)

        if if_exists == BaseDataset.REPLACE or not self.exists():
            self._create_table(normalized_column_names, with_lnglat)
        elif if_exists == BaseDataset.FAIL:
            raise self._already_exists_error()

        self._copyfrom(normalized_column_names, with_lnglat)

    def delete(self):
        raise ValueError(&#39;Method not allowed in DataFrameDataset. You should use a TableDataset: `Dataset(my_table)`&#39;)

    def compute_geom_type(self):
        &#34;&#34;&#34;Compute the geometry type from the data&#34;&#34;&#34;
        return self._get_geom_type()

    def _copyfrom(self, normalized_column_names, with_lnglat):
        geom_col = _get_geom_col_name(self._df)
        enc_type = _detect_encoding_type(self._df, geom_col)

        columns_normalized = []
        columns_origin = [geom_col]
        for norm, orig in normalized_column_names:
            columns_normalized.append(norm)
            columns_origin.append(orig)
        columns_normalized.append(&#39;the_geom&#39;)

        query = &#34;&#34;&#34;COPY {table_name}({columns}) FROM stdin WITH (FORMAT csv, DELIMITER &#39;|&#39;);&#34;&#34;&#34;.format(
            table_name=self._table_name,
            columns=&#39;,&#39;.join(columns_normalized))

        data = _rows(
            self._df,
            columns_origin,
            with_lnglat,
            geom_col,
            enc_type)

        self._context.upload(query, data)

    def _create_table(self, normalized_column_names, with_lnglat=None):
        query = &#39;&#39;&#39;BEGIN; {drop}; {create}; {cartodbfy}; COMMIT;&#39;&#39;&#39;.format(
            drop=self._drop_table_query(),
            create=self._create_table_query(normalized_column_names, with_lnglat),
            cartodbfy=self._cartodbfy_query())

        try:
            self._context.execute_long_running_query(query)
        except CartoRateLimitException as err:
            raise err
        except CartoException as err:
            raise CartoException(&#39;Cannot create table: {}.&#39;.format(err))

    def _create_table_query(self, normalized_column_names, with_lnglat=None):
        if with_lnglat is None:
            geom_type = _get_geom_col_type(self._df)
        else:
            geom_type = &#39;Point&#39;

        col = (&#39;{col} {ctype}&#39;)
        cols = &#39;, &#39;.join(col.format(col=norm,
                                    ctype=_dtypes2pg(self._df.dtypes[orig]))
                         for norm, orig in normalized_column_names)

        if geom_type:
            cols += &#39;, {geom_colname} geometry({geom_type}, 4326)&#39;.format(geom_colname=&#39;the_geom&#39;, geom_type=geom_type)

        create_query = &#39;&#39;&#39;CREATE TABLE {table_name} ({cols})&#39;&#39;&#39;.format(table_name=self._table_name, cols=cols)
        return create_query

    def _get_geom_type(self):
        &#34;&#34;&#34;Compute geom type of the local dataframe&#34;&#34;&#34;
        if not self._df.empty and &#39;geometry&#39; in self._df and len(self._df.geometry) &gt; 0:
            geometry = _first_value(self._df.geometry)
            if geometry and geometry.geom_type:
                return map_geom_type(geometry.geom_type)


def _rows(df, cols, with_lnglat, geom_col, enc_type):
    for i, row in df.iterrows():
        row_data = []
        the_geom_val = None
        lng_val = None
        lat_val = None
        for col in cols:
            val = row[col]
            if _is_null(val):
                val = &#39;&#39;
            if with_lnglat:
                if col == with_lnglat[0]:
                    lng_val = row[col]
                if col == with_lnglat[1]:
                    lat_val = row[col]
            if col == geom_col:
                the_geom_val = row[col]
            else:
                row_data.append(&#39;{}&#39;.format(val))

        if the_geom_val is not None:
            geom = decode_geometry(the_geom_val, enc_type)
            if geom:
                row_data.append(&#39;SRID=4326;{geom}&#39;.format(geom=geom.wkt))

        if len(row_data) &lt; len(cols) and with_lnglat is not None and lng_val is not None and lat_val is not None:
            row_data.append(&#39;SRID=4326;POINT({lng} {lat})&#39;.format(lng=lng_val, lat=lat_val))

        if len(row_data) &lt; len(cols):
            row_data.append(&#39;&#39;)

        csv_row = &#39;|&#39;.join(row_data)
        csv_row += &#39;\n&#39;

        yield csv_row.encode()


def _is_null(val):
    vnull = pd.isnull(val)
    if isinstance(vnull, bool):
        return vnull
    else:
        return vnull.all()


def _normalize_column_names(df):
    column_names = [c for c in df.columns if c not in Column.RESERVED_COLUMN_NAMES]
    normalized_columns = normalize_names(column_names)

    column_tuples = [(norm, orig) for orig, norm in zip(column_names, normalized_columns)]

    changed_cols = &#39;\n&#39;.join([
        &#39;\033[1m{orig}\033[0m -&gt; \033[1m{new}\033[0m&#39;.format(
            orig=orig,
            new=norm)
        for norm, orig in column_tuples if norm != orig])

    if changed_cols != &#39;&#39;:
        tqdm.write(&#39;The following columns were changed in the CARTO &#39;
                   &#39;copy of this dataframe:\n{0}&#39;.format(changed_cols))

    return column_tuples


def _get_geom_col_name(df):
    geom_col = getattr(df, &#39;_geometry_column_name&#39;, None)
    if geom_col is None:
        try:
            geom_col = next(x for x in df.columns if x.lower() in Column.SUPPORTED_GEOM_COL_NAMES)
        except StopIteration:
            pass

    return geom_col


def _detect_encoding_type(df, geom_col):
    if geom_col is not None:
        first_geom = _first_value(df[geom_col])
        if first_geom:
            return detect_encoding_type(first_geom)
    return &#39;&#39;


def _dtypes2pg(dtype):
    &#34;&#34;&#34;Returns equivalent PostgreSQL type for input `dtype`&#34;&#34;&#34;
    mapping = {
        &#39;float64&#39;: &#39;numeric&#39;,
        &#39;int64&#39;: &#39;bigint&#39;,
        &#39;float32&#39;: &#39;numeric&#39;,
        &#39;int32&#39;: &#39;integer&#39;,
        &#39;object&#39;: &#39;text&#39;,
        &#39;bool&#39;: &#39;boolean&#39;,
        &#39;datetime64[ns]&#39;: &#39;timestamp&#39;,
        &#39;datetime64[ns, UTC]&#39;: &#39;timestamp&#39;,
    }
    return mapping.get(str(dtype), &#39;text&#39;)


def _get_geom_col_type(df):
    geom_col = _get_geom_col_name(df)
    if geom_col is not None:
        first_geom = _first_value(df[geom_col])
        if first_geom:
            enc_type = detect_encoding_type(first_geom)
            geom = decode_geometry(first_geom, enc_type)
            if geom is not None:
                return geom.geom_type
        else:
            warn(&#39;Dataset with null geometries&#39;)


def _first_value(array):
    array = array.loc[~array.isnull()]  # Remove null values
    if len(array) &gt; 0:
        return array.iloc[0]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset"><code class="flex name class">
<span>class <span class="ident">DataFrameDataset</span></span>
<span>(</span><span>data, credentials=None, schema=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class DataFrameDataset(BaseDataset):
    def __init__(self, data, credentials=None, schema=None):
        super(DataFrameDataset, self).__init__()

        self._df = data

    @staticmethod
    def can_work_with(data):
        return isinstance(data, pd.DataFrame) or is_geojson(data)

    @classmethod
    def create(cls, data, credentials=None, schema=None):
        if is_geojson(data):
            data = load_geojson(data)

        save_index_as_column(data)

        return cls(data)

    @property
    def dataframe(self):
        &#34;&#34;&#34;Dataset DataFrame&#34;&#34;&#34;
        return self._df

    def get_geodataframe(self):
        &#34;&#34;&#34;Converts DataFrame into GeoDataFrame if possible&#34;&#34;&#34;
        gdf = compute_geodataframe(self)
        if not gdf.empty:
            self._df = gdf

        return self._df

    def download(self, limit, decode_geom, retry_times):
        self._is_ready_for_dowload_validation()

    def upload(self, if_exists, with_lnglat):
        self._is_ready_for_upload_validation()

        normalized_column_names = _normalize_column_names(self._df)

        if if_exists == BaseDataset.REPLACE or not self.exists():
            self._create_table(normalized_column_names, with_lnglat)
        elif if_exists == BaseDataset.FAIL:
            raise self._already_exists_error()

        self._copyfrom(normalized_column_names, with_lnglat)

    def delete(self):
        raise ValueError(&#39;Method not allowed in DataFrameDataset. You should use a TableDataset: `Dataset(my_table)`&#39;)

    def compute_geom_type(self):
        &#34;&#34;&#34;Compute the geometry type from the data&#34;&#34;&#34;
        return self._get_geom_type()

    def _copyfrom(self, normalized_column_names, with_lnglat):
        geom_col = _get_geom_col_name(self._df)
        enc_type = _detect_encoding_type(self._df, geom_col)

        columns_normalized = []
        columns_origin = [geom_col]
        for norm, orig in normalized_column_names:
            columns_normalized.append(norm)
            columns_origin.append(orig)
        columns_normalized.append(&#39;the_geom&#39;)

        query = &#34;&#34;&#34;COPY {table_name}({columns}) FROM stdin WITH (FORMAT csv, DELIMITER &#39;|&#39;);&#34;&#34;&#34;.format(
            table_name=self._table_name,
            columns=&#39;,&#39;.join(columns_normalized))

        data = _rows(
            self._df,
            columns_origin,
            with_lnglat,
            geom_col,
            enc_type)

        self._context.upload(query, data)

    def _create_table(self, normalized_column_names, with_lnglat=None):
        query = &#39;&#39;&#39;BEGIN; {drop}; {create}; {cartodbfy}; COMMIT;&#39;&#39;&#39;.format(
            drop=self._drop_table_query(),
            create=self._create_table_query(normalized_column_names, with_lnglat),
            cartodbfy=self._cartodbfy_query())

        try:
            self._context.execute_long_running_query(query)
        except CartoRateLimitException as err:
            raise err
        except CartoException as err:
            raise CartoException(&#39;Cannot create table: {}.&#39;.format(err))

    def _create_table_query(self, normalized_column_names, with_lnglat=None):
        if with_lnglat is None:
            geom_type = _get_geom_col_type(self._df)
        else:
            geom_type = &#39;Point&#39;

        col = (&#39;{col} {ctype}&#39;)
        cols = &#39;, &#39;.join(col.format(col=norm,
                                    ctype=_dtypes2pg(self._df.dtypes[orig]))
                         for norm, orig in normalized_column_names)

        if geom_type:
            cols += &#39;, {geom_colname} geometry({geom_type}, 4326)&#39;.format(geom_colname=&#39;the_geom&#39;, geom_type=geom_type)

        create_query = &#39;&#39;&#39;CREATE TABLE {table_name} ({cols})&#39;&#39;&#39;.format(table_name=self._table_name, cols=cols)
        return create_query

    def _get_geom_type(self):
        &#34;&#34;&#34;Compute geom type of the local dataframe&#34;&#34;&#34;
        if not self._df.empty and &#39;geometry&#39; in self._df and len(self._df.geometry) &gt; 0:
            geometry = _first_value(self._df.geometry)
            if geometry and geometry.geom_type:
                return map_geom_type(geometry.geom_type)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cartoframes.data.dataset.registry.base_dataset.BaseDataset" href="base_dataset.html#cartoframes.data.dataset.registry.base_dataset.BaseDataset">BaseDataset</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.can_work_with"><code class="name flex">
<span>def <span class="ident">can_work_with</span></span>(<span>data)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def can_work_with(data):
    return isinstance(data, pd.DataFrame) or is_geojson(data)</code></pre>
</details>
</dd>
<dt id="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>data, credentials=None, schema=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def create(cls, data, credentials=None, schema=None):
    if is_geojson(data):
        data = load_geojson(data)

    save_index_as_column(data)

    return cls(data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.compute_geom_type"><code class="name flex">
<span>def <span class="ident">compute_geom_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the geometry type from the data</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compute_geom_type(self):
    &#34;&#34;&#34;Compute the geometry type from the data&#34;&#34;&#34;
    return self._get_geom_type()</code></pre>
</details>
</dd>
<dt id="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def delete(self):
    raise ValueError(&#39;Method not allowed in DataFrameDataset. You should use a TableDataset: `Dataset(my_table)`&#39;)</code></pre>
</details>
</dd>
<dt id="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, limit, decode_geom, retry_times)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def download(self, limit, decode_geom, retry_times):
    self._is_ready_for_dowload_validation()</code></pre>
</details>
</dd>
<dt id="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.get_geodataframe"><code class="name flex">
<span>def <span class="ident">get_geodataframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts DataFrame into GeoDataFrame if possible</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_geodataframe(self):
    &#34;&#34;&#34;Converts DataFrame into GeoDataFrame if possible&#34;&#34;&#34;
    gdf = compute_geodataframe(self)
    if not gdf.empty:
        self._df = gdf

    return self._df</code></pre>
</details>
</dd>
<dt id="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>self, if_exists, with_lnglat)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def upload(self, if_exists, with_lnglat):
    self._is_ready_for_upload_validation()

    normalized_column_names = _normalize_column_names(self._df)

    if if_exists == BaseDataset.REPLACE or not self.exists():
        self._create_table(normalized_column_names, with_lnglat)
    elif if_exists == BaseDataset.FAIL:
        raise self._already_exists_error()

    self._copyfrom(normalized_column_names, with_lnglat)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cartoframes.data.dataset.registry.base_dataset.BaseDataset" href="base_dataset.html#cartoframes.data.dataset.registry.base_dataset.BaseDataset">BaseDataset</a></b></code>:
<ul class="hlist">
<li><code><a title="cartoframes.data.dataset.registry.base_dataset.BaseDataset.credentials" href="base_dataset.html#cartoframes.data.dataset.registry.base_dataset.BaseDataset.credentials">credentials</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.base_dataset.BaseDataset.dataframe" href="base_dataset.html#cartoframes.data.dataset.registry.base_dataset.BaseDataset.dataframe">dataframe</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.base_dataset.BaseDataset.exists" href="base_dataset.html#cartoframes.data.dataset.registry.base_dataset.BaseDataset.exists">exists</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.base_dataset.BaseDataset.is_public" href="base_dataset.html#cartoframes.data.dataset.registry.base_dataset.BaseDataset.is_public">is_public</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.base_dataset.BaseDataset.schema" href="base_dataset.html#cartoframes.data.dataset.registry.base_dataset.BaseDataset.schema">schema</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.base_dataset.BaseDataset.table_name" href="base_dataset.html#cartoframes.data.dataset.registry.base_dataset.BaseDataset.table_name">table_name</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cartoframes.data.dataset.registry" href="index.html">cartoframes.data.dataset.registry</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset" href="#cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset">DataFrameDataset</a></code></h4>
<ul class="two-column">
<li><code><a title="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.can_work_with" href="#cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.can_work_with">can_work_with</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.compute_geom_type" href="#cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.compute_geom_type">compute_geom_type</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.create" href="#cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.create">create</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.delete" href="#cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.delete">delete</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.download" href="#cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.download">download</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.get_geodataframe" href="#cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.get_geodataframe">get_geodataframe</a></code></li>
<li><code><a title="cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.upload" href="#cartoframes.data.dataset.registry.dataframe_dataset.DataFrameDataset.upload">upload</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>