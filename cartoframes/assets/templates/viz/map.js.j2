{% if has_legends %}
  {% include 'viz/legends.js.j2' %}
{% endif %}
{% if has_widgets %}
  {% include 'viz/widgets.js.j2' %}
{% endif %}
{% include 'error/parser.js.j2' %}
{% include 'utils/base64.js.j2' %}
{% include 'utils/format.js.j2' %}

const responsive = document.querySelector('as-responsive-content');

function onReady() {
  const BASEMAPS = {
    DarkMatter: carto.basemaps.darkmatter,
    Voyager: carto.basemaps.voyager,
    Positron: carto.basemaps.positron
  };

  if ("{{mapboxtoken}}") {
    mapboxgl.accessToken = "{{mapboxtoken}}";
  }
  // Fetch CARTO basemap if it's there, else try to use other supplied style
  const map = new mapboxgl.Map({
    container: 'map',
    style: BASEMAPS['{{basemap}}'] || '{{basemap}}' || {
        'version': 8,
        'sources': {},
        'layers': [{
            'id': 'background',
            'type': 'background',
            'paint': {
                'background-color': '{{basecolor}}'
            }
        }]
    },
    zoom: 9,
    dragRotate: false
  });

  const mapInfo$ = document.getElementById('map-info');

  {% if show_info %}
    function updateMapInfo() {
      const center = map.getCenter();
      const lat = center.lat.toFixed(6);
      const lng = center.lng.toFixed(6);
      const zoom = map.getZoom().toFixed(2);

      mapInfo$.innerText = `viewport={'zoom': ${zoom}, 'lat': ${lat}, 'lng': ${lng}}`;
    }

    map.on('zoom', updateMapInfo);
    map.on('move', updateMapInfo);
  {% endif %}

  const layers = {{layers|tojson}};

  map.fitBounds({{bounds}}, {animate: false, padding: 50, maxZoom: 14});

  {% if camera != none %}
    map.flyTo({{ camera|clear_none|tojson }});
  {% endif %}

  const mapLayers = [];

  const interactiveLayers = [];
  const interactiveMapLayers = [];

  layers.forEach((layer, index) => {
    const factory = new SourceFactory();
    const mapSource = factory.createSource(layer);
    const mapViz = new carto.Viz(layer['viz']);
    const mapLayer = new carto.Layer(`layer${index}`, mapSource, mapViz);

    mapLayers.push(mapLayer);

    try {
      mapLayer._updateLayer.catch(displayError);
    } catch (err) {
      throw err;
    }

    mapLayer.addTo(map);

    if (layer.interactivity) {
      interactiveLayers.push(layer);
      interactiveMapLayers.push(mapLayer);
    }

    {% if has_legends %}
    if (layer.legend) {
      createLegend(mapLayer, layer.legend, layers.length - index - 1);
    }
    {% endif %}

    if (layer.widgets.length) {
      layer.widgets.forEach((widget, widgetIndex) => {
        widget.element = document.querySelector(`#layer${layers.length - index - 1}_widget${widgetIndex}-${widget.name}`);
      });

      bridgeLayerWidgets(carto, mapLayer, mapSource, map, layer.widgets);

      mapLayer.on('updated', () => {
        layer.widgets
          .filter((widget) => widget.has_variable)
          .forEach((widget, widgetIndex) => {
            renderWidget(mapLayer, widget, mapViz.variables[widget.name], layers.length - index - 1, widgetIndex);
          })
      });
    }
  });

  if (interactiveLayers.length > 0) {
    const interactivity = new carto.Interactivity(interactiveMapLayers);
    const popup = new mapboxgl.Popup({
      closeButton: false,
      closeOnClick: false
    });

    let clickAttrs = [];
    let hoverAttrs = [];
    interactiveLayers.forEach((interactiveLayer) => {
      interactiveLayer.interactivity.forEach((interactivityDef) => {
        if (interactivityDef.event === 'click') {
          clickAttrs = clickAttrs.concat(interactivityDef.attrs);
        } else if (interactivityDef.event === 'hover') {
          hoverAttrs = hoverAttrs.concat(interactivityDef.attrs);
        }
      });
    });

    resetPopupClick(interactivity);
    if (clickAttrs.length > 0) {
      setPopupsClick(popup, interactivity, clickAttrs);
    }

    resetPopupHover(interactivity);
    if (hoverAttrs.length > 0) {
      setPopupsHover(popup, interactivity, hoverAttrs);
    }
  }

  {% if default_legend %}
    createDefaultLegend(mapLayers);
  {% endif %}

  function updatePopup(popup, event, attrs) {
    if (event.features.length > 0) {
      let popupHTML = '';
      const layerIDs = [];

      for (const feature of event.features) {
        if (layerIDs.includes(feature.layerId)) {
          continue;
        }
        // Track layers to add only one feature per layer
        layerIDs.push(feature.layerId);
    
        for (const item of attrs) {
          const variable = feature.variables[item.name];
          if (variable) {
            let value = variable.value;
            value = formatValue(value)

            popupHTML = `
              <span class="popup-name">${item.title}</span>
              <span class="popup-value">${value}</span>
            ` + popupHTML;
          }
        }
      }

      popup
          .setLngLat([event.coordinates.lng, event.coordinates.lat])
          .setHTML(`<div class="popup-content">${popupHTML}</div>`);

      if (!popup.isOpen()) {
        popup.addTo(map);
      }
    } else {
      popup.remove();
    }
  }

  function resetPopupClick(interactivity) {
    interactivity.off('featureClick');
  }

  function resetPopupHover(interactivity) {
    interactivity.off('featureHover');
  }

  function setPopupsClick(popup, interactivity, attrs) {
    interactivity.on('featureClick', (event) => {
      updatePopup(popup, event, attrs)
    });
  }

  function setPopupsHover(popup, interactivity, attrs) {
    interactivity.on('featureHover', (event) => {
      updatePopup(popup, event, attrs)
    });
  }

  function SourceFactory() {
    const sourceTypes = {
      GeoJSON: (layer) => new carto.source.GeoJSON(_decodeJSONQuery(layer.query)),
      Query: (layer) => {
        const auth = {
          username: layer.credentials['username'],
          apiKey: layer.credentials['api_key'] || 'default_public'
        };
        const config = {
          serverURL: layer.credentials['base_url'] || `https://${layer.credentials['username']}.carto.com/`
        };
        return new carto.source.SQL(layer.query, auth, config)
      },
      MVT: (layer) => new carto.source.MVT(layer.query.file, JSON.parse(layer.query.metadata)),
    }

    this.createSource = (layer) => {
      return sourceTypes[layer.type](layer);
    }
  }
}

function setReady () {
  try {
    onReady()
  } catch (e) {
    displayError(e);
  }
}

function displayError(e) {
  const error$ = document.getElementById('error-container');
  const errors$ = error$.getElementsByClassName('errors');
  const stacktrace$ = document.getElementById('error-stacktrace');

  errors$[0].innerHTML = e.name;
  errors$[1].innerHTML = e.name;
  errors$[2].innerHTML = e.type;
  errors$[3].innerHTML = e.message.replace(e.type, '');

  error$.style.visibility = 'visible';

  const stack = parse(e.stack);
  const list = stack.map(item => {
    return `<li>
      at <span class="stacktrace-method">${item.methodName}:</span>
      (${item.file}:${item.lineNumber}:${item.column})
    </li>`;
  });

  stacktrace$.innerHTML = list.join('\n');
}

function _decodeJSONQuery(query) {
  return JSON.parse(Base64.decode(query.replace(/b\'/, '\'')))
}

responsive.addEventListener('ready', setReady);
