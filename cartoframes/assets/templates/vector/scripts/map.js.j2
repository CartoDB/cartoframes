{% include 'error/parser.js.j2' %}

const responsive = document.querySelector('as-responsive-content');

function onReady() {
  const BASEMAPS = {
    DarkMatter: carto.basemaps.darkmatter,
    Voyager: carto.basemaps.voyager,
    Positron: carto.basemaps.positron
  };

  if ("{{mapboxtoken}}") {
    mapboxgl.accessToken = "{{mapboxtoken}}";
  }
  // Fetch CARTO basemap if it's there, else try to use other supplied style
  const map = new mapboxgl.Map({
    container: 'map',
    style: BASEMAPS['{{basemapstyle}}'] || "{{basemapstyle}}",
    zoom: 9,
    dragRotate: false
  });

  const credentials = {{credentials|tojson}};

  carto.setDefaultAuth({
    username: credentials['username'],
    apiKey: credentials['api_key'] || 'default_public'
  });

  carto.setDefaultConfig({
      serverURL: credentials['base_url'] || `https://${credentials['user']}.carto.com/`
  });

  const sources = {{sources|tojson}};

  map.fitBounds({{bounds}}, {animate: false});

  {% if camera != none %}
    map.flyTo({{ camera|clear_none|tojson }});
  {% endif %}

  sources.forEach((elem, idx) => {
    let temp_source = null;
    if (elem.is_local) {
      let local_json = JSON.parse(elem.source);
      temp_source = new carto.source.GeoJSON(local_json);
    } else {
      temp_source = new carto.source.SQL(elem.source);
    }

    const viz = new carto.Viz(elem['viz']);

    const layer = new carto.Layer(
        'layer' + idx,
        temp_source,
        viz
    );

    layer.addTo(map);

    if (elem.interactivity) {
      const interactivity = new carto.Interactivity(layer);
      const tempPopup = new mapboxgl.Popup({
        closeButton: false,
        closeOnClick: false
      });

      const { event, header, values} = elem.interactivity;

      if (event === 'click') {
        setPopupsClick(tempPopup, interactivity, header, values);
      } else if (event === 'hover') {
        setPopupsHover(tempPopup, interactivity, header, values);
      }
    }

    function setPopupsClick(tempPopup, interactivity, popupHeader, values) {
      interactivity.off('featureHover', (event) => {
          updatePopup(tempPopup, event, popupHeader, values)
      });
      interactivity.on('featureClick', (event) => {
          updatePopup(tempPopup, event, popupHeader, values)
      });
    }
    
    function setPopupsHover(tempPopup, interactivity, popupHeader, values) {
      interactivity.off('featureClick', (event) => {
          updatePopup(tempPopup, event, popupHeader, values)
      });
      interactivity.on('featureHover', (event) => {
          updatePopup(tempPopup, event, popupHeader, values)
      });
    }

    function updatePopup(layer_popup, event, popupHeader, values) {
      if (event.features.length > 0) {
        const feature = event.features[0];
        const variables = values && values.length
          ? Object.keys(feature.variables).filter(variable => values.include(variable))
          : Object.keys(feature.variables);

        let popupHTML = popupHeader ? `<h1>${popupHeader}</h1>` : ``;
        
        Object.keys(feature.variables).forEach((name) => {
            const variable = feature.variables[name];

            popupHTML += `
              <h3 class="h3">${name}</h3>
              <p class="description open-sans">${JSON.stringify(variable.value)}</p>
            `;
        });
        
        layer_popup
            .setLngLat([event.coordinates.lng, event.coordinates.lat])
            .setHTML(`<div>${popupHTML}</div>`);
        
        if (!layer_popup.isOpen()) {
          layer_popup.addTo(map);
        }
      } else {
        layer_popup.remove();
      }
    }
  });
}

function setReady () {
  try {
    onReady()
  } catch (e) {
    const error$ = document.getElementById('error-container');
    const errors$ = error$.getElementsByClassName('errors');
    const stacktrace$ = document.getElementById('error-stacktrace');

    errors$[0].innerHTML = e.name;
    errors$[1].innerHTML = e.name;
    errors$[2].innerHTML = e.type;
    errors$[3].innerHTML = e.message.replace(e.type, '');

    error$.style.visibility = 'visible';

    const stack = parse(e.stack);
    const list = stack.map(item => {
      return `<li>
        at <span class="stacktrace-method">${item.methodName}:</span>
        (${item.file}:${item.lineNumber}:${item.column})
      </li>`;
    });

    stacktrace$.innerHTML = list.join('\n');
  }
}

responsive.addEventListener('ready', setReady);